# Towards a Framework for Developing Verified Assemblers for the ELF Format

This material contains the implementation and applications of the
framework presented in our paper. The framework is a template of
verified assemblers that implements the architecture-independent
components. Its code mainly resides in [assembler](assembler) directory. Beside
that, we utilize CSLED to simplify the implementation and verification
of the instruction encoding, whose code resides in [csled](csled) directory.
As discussed in Section 4 and Section 5 of the paper, we apply our
framework to X86 and RISC-V to generate verified assemblers and
connect them to the backend of Stack-Aware CompCert (based on CompCert
v3.8). These code respectively reside in [x86](x86) and [riscV](riscV) directories.

## Prerequisites

> The following guide assumes that the architecture of your machine is
X86-64. 

To compile CompCert v3.8 and our framework
(including CSLED), the following software components are required:
* GCC
* Ocaml 4.09.0
* Coq 8.12.1
* Bison 3.6 (required by CSLED)
* Flex 2.6.4 (required by CSLED)
* riscv-gnu-toolchain (required by RISC-V)
* qemu-7.0.0 (required by RISC-V)

### Install Ocaml and Coq

We recommend using the `opam` package manager to set up a build
environment with the following commands:

    # Install and initialize opam (if you haven't used it before)
    sudo apt install opam
    opam init --bare

    # Create an "opam switch" dedicated to building the framework
    opam update
    opam switch create aplas23-assembler ocaml-base-compiler.4.09.0

    # Install the Coq and parser
    opam install coq.8.12.1 menhir.20211012

    # Update the environment
    eval $(opam env)
    
### Install Bison and Flex

    # Install flex
    sudo apt install flex

    # Install Bison v3.6 from source
    cd ~ && wget https://ftp.gnu.org/gnu/bison/bison-3.6.1.tar.xz
    tar -xf bison-3.6.1.tar.xz
    cd bison-3.6.1
    ./configure && make -j$(nproc)
    sudo make install

### Install GNU RISC-V Toolchain and Qemu (Optional)

If you want to build RISC-V assemblers and evaluate it on RISC-V test
cases, you need to install riscv-gnu-toolchain to generate executable
ELF files from the output of the assembler and qemu to simulate the
execution of these files on your machine. Since `apt` does not provide
the toolchain of rv32, we need to download its built package from the
github.

    # Install 64-bit riscv-gnu-toolchain
    sudo apt install gcc-riscv64-linux-gnu
    riscv64-linux-gnu-gcc -v

    # Install 32-bit riscv-gnu-toolchain (required if you want to build 32-bit RISC-V assemblers)
    # Download built package (roughly 600MB)
    cd ~ & wget https://github.com/riscv-collab/riscv-gnu-toolchain/releases\/download/2022.09.30/riscv32-glibc-ubuntu-20.04-nightly-2022.09.30-nightly.tar.gz -O riscv32-gnu-toolchain.tar.gz
    tar -xf riscv32-gnu-toolchain.tar.gz
    ~/riscv32-gnu-toolchain/bin/riscv32-unknown-linux-gnu-gcc -v

    # Install Qemu
    # Prerequisites of Qemu
    sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \
              gawk build-essential texinfo gperf libtool patchutils bc \
              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev libsdl2-dev \
              git tmux python3 python3-pip ninja-build
    # Install Qemu from source
    cd ~ && wget https://download.qemu.org/qemu-7.0.0.tar.xz
    tar -xf qemu-7.0.0.tar.xz
    cd qemu-7.0.0

    # Build Qemu that simulates 64-bit RISC-V
    ./configure --target-list=riscv64-softmmu,riscv64-linux-user
    make -j$(nproc)
    sudo make install
    qemu-riscv64 --version

    # Build Qemu that simulates 32-bit RISC-V
    ./configure --target-list=riscv32-softmmu,riscv32-linux-user
    make -j$(nproc)
    sudo make install
    qemu-riscv32 --version

## Build CompCert and The framework

**Note**: It is time consuming to build the whole compiler due to the
  huge amount of proofs generated by CSLED. CSLED generates $O(n^2)$
  lemmas to verify the consistency between encoders and decoders
  where $n$ is the number of instructions. So it is impractical for
  the readers to run the proofs. We provide three options (O0, O1 and
  O2) to speed up the proofs by replacing the enormous proof scripts
  with `Admitted` so that it can save lots of time. Note that we have
  already checked the complete proofs in our machines. We also
  evaluate the consumption of time which is listed below.

| Options | Time Consumption |
|---------|:----------------:|
| O0 (no `Admitted`)     | ~1h30min        |
| O1 (half `Admitted`)   | ~40min          |
| O2 (all `Admitted`)    | ~10min          |

In the following configuration, we all set `-csled-opt` to `O2` to
reduce the consumption of time. The generated proofs are in
[autogen/EncConsistency.v](autogen/EncConsistency.v) and you can check
them after `make csled`.

### X86-64

    # Configure to X86-64
    ./configure x86_64-linux -csled-opt O2
    # Use CSLED to generate encoder, decoder and their proofs
    make csled
    make -j$(nproc) all

### X86-32

    ./configure x86_32-linux -csled-opt O2
    make csled
    make -j$(nproc) all

### RISC-V 32

    # Toolprefix is the prefix of the name of the external C compiler
    # Simulator is set to qemu simulator
    # 'simu-ld' denotes the path to the dynamic loader, which is provided by riscv-gnu-toolchain
    ./configure rv32-linux -toolprefix ~/riscv/bin/riscv32-unknown-linux-gnu- -simulator qemu-riscv32 -simu-ld ~/riscv/sysroot -csled-opt O2
    make csled
    make -j$(nproc) all

### RISC-V RV64
    # As we use apt to install 64-bit riscv-gnu-toolchain, their paths are already in the environment
    ./configure rv64-linux -toolprefix riscv64-linux-gnu- -simulator qemu-riscv64 -simu-ld /usr/riscv64-linux-gnu/ -csled-opt O2
    make csled
    make -j$(nproc) all

## Structure

We show the structure following Table 1 in our paper.

| Components            | Framework       | Application of X86 |Application of RISCV       |
|----------------------|-----------------|---------------------|-------------------------|
| $P_{\mathcal{A}}$: Realistic Assembly   | [assembler/RealAsm.v](assembler/RealAsm.v) | [x86/RealAsmArchi.v](x86/RealAsmArchi.v)<br>[x86/Asm.v](x86/Asm.v)  | [riscV/RealAsmArchi.v](riscV/RealAsmArchi.v)<br>[riscV/Asm.v](riscV/Asm.v)|
| $P_{\mathcal{R}}$: Relocatable Programs | [assembler/RelocProg.v](assembler/RelocProg.v)<br>[assembler/RelocProgSemantics.v](assembler/RelocProgSemantics.v)($[\![P_1]\!]$)<br>[assembler/RelocProgSemantics1.v](assembler/RelocProgSemantics1.v)($[\![P_2]\!]$)<br>[assembler/RelocProgSemantics2.v](assembler/RelocProgSemantics2.v)($[\![P_3]\!]$) | [x86/RelocProgSemanticsArchi.v](x86/RelocProgSemanticsArchi.v)<br>[x86/RelocProgSemanticsArchi1.v](x86/RelocProgSemanticsArchi1.v) | [riscV/RelocProgSemanticsArchi.v](riscV/RelocProgSemanticsArchi.v)<br>[riscV/RelocProgSemanticsArchi1.v](riscV/RelocProgSemanticsArchi1.v) | 
| $P_{\mathcal{E}}$: Relocatable ELF | [elf/RelocElf.v](elf/RelocElf.v)<br>[elf/RelocElfSemantics.v](elf/RelocElfSemantics.v)($[\![P_4]\!]$) | [x86/RelocElfArchi.v](x86/RelocElfArchi.v) | [riscV/RelocElfArchi.v](x86/RelocElfArchi.v) |
$\mathbb{C}_1$: Generation of Relocatable Programs | [assembler/Symbtablegen.v](assembler/Symbtablegen.v)<br>[assembler/Symbtablegenproof.v](assembler/Symbtablegenproof.v) | [x86/SymbtablegenproofArchi.v](x86/SymbtablegenproofArchi.v) | [riscV/SymbtablegenproofArchi.v](riscV/SymbtablegenproofArchi.v) |
$\mathbb{C}_2$: Generation of Relocation Table | [assembler/Reloctablesgen.v](assembler/Reloctablesgen.v)<br>[assembler/Reloctablesgenproof.v](assembler/Reloctablesgenproof.v) | [x86/ReloctablesgenArchi.v](x86/ReloctablesgenArchi.v)<br>[x86/ReloctablesgenproofArchi.v](x86/ReloctablesgenproofArchi.v) | [riscV/ReloctablesgenArchi.v](x86/ReloctablesgenArchi.v)<br>[riscV/ReloctablesgenproofArchi.v](x86/ReloctablesgenproofArchi.v) |
$\mathbb{C}_3$: Instruction and Data Encoding | [assembler/RelocBingen.v](assembler/RelocBingen.v)<br>[assembler/RelocBingenproof.v](assembler/RelocBingenproof.v) | Translators: [x86/TranslateInstr.v](x86/TranslateInstr.v)<br>[x86/RelocBinDecode.v](x86/RelocBinDecode.v)<br>CSLED Spec: [x86.csled](csled/x86/x86.csled) | Translators: [riscV/TranslateInstr.v](riscV/TranslateInstr.v)<br>[riscV/RelocBinDecode.v](riscV/RelocBinDecode.v)<br>CSLED Spec: [riscv.csled](csled/riscv/riscv.csled) |
$\mathbb{C}_4$: Generation of Relocatable ELF | [elf/RelocElfgen.v](elf/RelocElfgen.v)<br>[elf/RelocElfgenproof.v](elf/RelocElfgenproof.v) | [x86/RelocElfgenproofArchi.v](x86/RelocElfgenproofArchi.v) | [riscV/RelocElfgenproofArchi.v](riscV/RelocElfgenproofArchi.v) |

By the way, the top-level definitions of the target printers are defined
in [x86/CompilerAux.v](x86/CompilerAux.v) and [riscV/CompilerAux.v](riscV/CompilerAux.v).


## Evaluation

### Run The Test Cases

As described in Section 5 of the paper, we evaluate the generated
assemblers with the test cases provided by CompCert. They reside in
[test](test) folder.

Before you run the code on your machine, make sure that `gcc` has been installed. Beside that, we need to install `gcc-muitilib` to get the standard library for X86-32.

    sudo apt install gcc-multilib

If you configure the assembler to X86-32/64, you can simply run the
following code to evaluate the testï¼š

    cd test
    # Compile the test cases
    make clean && make all
    # Start the test
    make test

If you configure to RV-32/64, you need to ensure that the RISC-V GNU
Toolchain and Qemu have been installed and configured in your machine.
The installation and configuration are introduced above. If they are
all done, you can type the same commands to run the test.

    cd test
    # Compile the test cases
    make clean && make all
    # Start the test
    make test

### Performance Evaluation

We evaluate the performance of the generated code with the scripts
provided by CompCert in [test/c/Makefile](test/c/Makefile). This code
is compiled by CompCert and assembled by our assemblers or by the GNU
assembler (GAS). The scripts measure the time (in seconds) by running
the code multiple times. and calculating their average value. 

    # Evaluate the code generated by our assemblers
    cd test/c
    make all
    make bench

    # Evaluate the code generated by CompCert and GNU assembler
    cd test/c
    make all_compcert_gcc
    make bench_compcert_gcc

 We run the above scripts in WSL2 Ubuntu20.04 on a machine with
 Intel(R) Core(TM) i9-12900H CPU. The result of the evaluation is
 shown in the following tables.

 | Test cases | Our work in X86-32  | GAS in X86-32 | Our work in X86-64  | GAS in X86-64 |
|--|:--:|:--:|:--:|:--:|
| fib            | 0.044 | 0.039 | 0.042 | 0.041 |
| integr         | 0.022 | 0.022 | 0.023 | 0.023 |
| qsort          | 0.071 | 0.073 | 0.069 | 0.069 |
| fft            | 0.057 | 0.059 | 0.053 | 0.054 |
| fftsp          | 0.030 | 0.029 | 0.020 | 0.017 |
| fftw           | 0.035 | 0.031 | 0.081 | 0.027 |
| sha1           | 0.037 | 0.036 | 0.030 | 0.031 |
| sha3           | 0.039 | 0.043 | 0.020 | 0.020 |
| aes            | 0.044 | 0.044 | 0.045 | 0.045 |
| almabench      | 0.250 | 0.243 | 0.123 | 0.123 |
| lists          | 0.047 | 0.046 | 0.046 | 0.046 |
| binarytrees    | 0.018 | 0.017 | 0.015 | 0.014 |
| fannkuch       | 0.143 | 0.127 | 0.133 | 0.129 |
| knucleotide    | 0.061 | 0.061 | 0.072 | 0.074 |
| mandelbrot     | 0.086 | 0.062 | 0.086 | 0.062 |
| nbody          | 0.078 | 0.078 | 0.055 | 0.054 |
| nsieve         | 0.070 | 0.072 | 0.064 | 0.067 |
| nsievebits     | 0.065 | 0.064 | 0.060 | 0.055 |
| spectral       | 0.072 | 0.072 | 0.072 | 0.072 |
| vmach          | 0.038 | 0.038 | 0.040 | 0.040 |
| bisect         | 0.050 | 0.050 | 0.049 | 0.050 |
| chomp          | 0.095 | 0.093 | 0.101 | 0.101 |
| perlin         | 0.410 | 0.402 | 0.031 | 0.028 |
| siphash24      | 0.122 | 0.123 | 0.047 | 0.047 |

 | Test cases | Our work in RV-32  | GAS in RV-32 | Our work in RV-64  | GAS in RV-64 |
|--|:--:|:--:|:--:|:--:|
| fib            | 0.433 | 0.430 | 0.442 | 0.445 |
| integr         | 0.212 | 0.221 | 0.216 | 0.216 |
| qsort          | 0.183 | 0.181 | 0.189 | 0.188 |
| fft            | 0.372 | 0.375 | 0.376 | 0.369 |
| fftsp          | 0.839 | 0.858 | 0.784 | 0.772 |
| fftw           | 0.721 | 0.736 | 0.742 | 0.711 |
| sha1           | 0.130 | 0.141 | 0.162 | 0.156 |
| sha3           | 0.173 | 0.170 | 0.114 | 0.101 |
| aes            | 0.130 | 0.177 | 0.143 | 0.177 |
| almabench      | 3.684 | 3.819 | 3.686 | 3.586 |
| lists          | 0.090 | 0.092 | 0.056 | 0.057 |
| binarytrees    | 0.188 | 0.166 | 0.171 | 0.156 |
| fannkuch       | 0.259 | 0.261 | 0.275 | 0.272 |
| knucleotide    | 0.314 | 0.303 | 0.298 | 0.307 |
| mandelbrot     | 0.744 | 0.718 | 0.648 | 0.660 |
| nbody          | 1.606 | 1.605 | 1.527 | 1.525 |
| nsieve         | 0.128 | 0.132 | 0.138 | 0.136 |
| nsievebits     | 0.151 | 0.160 | 0.185 | 0.172 |
| spectral       | 0.686 | 0.504 | 0.474 | 0.478 |
| vmach          | 0.237 | 0.186 | 0.317 | 0.183 |
| bisect         | 0.220 | 0.226 | 0.224 | 0.216 |
| chomp          | 0.481 | 0.445 | 0.451 | 0.446 |
| perlin         | 0.488 | 0.499 | 0.885 | 0.857 |
| siphash24      | 0.168 | 0.174 | 0.128 | 0.129 |

The evaluation shows that the performance of the generated code of our
assemblers is slower about 3% than that generated by GCC. This result
is taken from the average of all test cases in `test\c` folder. And
the performance comparison is calculated by this formular
$(t_{gcc}/t_{ourwork}-1)$. 

We also compare the sizes of the generated reloatable ELF files
between our assembler and GNU assembler. The result is listed below
(unit is bytes):

| Test cases | Our work in X86-32  | GAS in X86-32 | Our work in X86-64  | GAS in X86-64 |
|--|:--:|:--:|:--:|:--:|
| fib            | 24221 | 18936 | 30118 | 23392 |
| integr         | 17673 | 10960 | 21717 | 14064 |
| qsort          |  5437 |  2436 |  7446 |  3408 |
| fft            |  8777 |  4260 | 11126 |  5824 |
| fftsp          | 11666 |  5944 | 17872 |  8736 |
| fftw           |  4139 |  1580 |  5464 |  2168 |
| sha1           |  6792 |  3296 |  8609 |  4520 |
| sha3           |  6744 |  3288 |  8538 |  4568 |
| aes            |  5243 |  2152 |  6821 |  3008 |
| almabench      |  3259 |  1096 |  4159 |  1584 |
| lists          |  3642 |  1380 |  4534 |  1912 |
| binarytrees    | 10461 |  5396 | 17353 |  7656 |
| fannkuch       |  4415 |  1796 |  6681 |  2608 |
| knucleotide    |  4114 |  1596 |  5283 |  2352 |
| mandelbrot     |  6605 |  3428 |  9292 |  4728 |
| nbody          |  3422 |  1240 |  4266 |  1736 |
| nsieve         |  3751 |  1416 |  4889 |  1864 |
| nsievebits     |  8637 |  4484 | 10721 |  5776 |
| spectral       |  4218 |  1668 |  5412 |  2344 |
| vmach          |  7423 |  3516 |  9597 |  4576 |
| bisect         | 10496 |  6036 | 10377 |  5944 |
| chomp          |  8658 |  4904 |  9006 |  4280 |
| perlin         |  4847 |  1992 |  5970 |  2808 |
| siphash24      |  5214 |  2316 |  7038 |  3056 |

| Test cases | Our work in RV-32  | GAS in RV-32 | Our work in RV-64  | GAS in RV-64 |
|--|:--:|:--:|:--:|:--:|
| aes           | 26170 | 23064 | 22298 | 19920 |
| almabench     | 20348 | 15032 | 16140 | 12172 |
| binarytrees   |  5970 |  3728 |  4582 |  2844 |
| bisect        |  9654 |  7464 |  7382 |  5524 |
| chomp         | 14752 | 12408 | 10904 |  8820 |
| fannkuch      |  4282 |  3320 |  3374 |  2456 |
| fft           |  7202 |  6016 |  5642 |  4512 |
| fftsp         |  7085 |  5992 |  5585 |  4516 |
| fftw          |  5790 |  3408 |  4418 |  2600 |
| fib           |  3481 |  1592 |  2705 |  1244 |
| integr        |  3821 |  1800 |  2985 |  1448 |
| knucleotide   | 12271 | 10808 |  9307 |  7864 |
| lists         |  4946 |  3504 |  3830 |  2592 |
| mandelbrot    |  4781 |  2936 |  3673 |  2188 |
| nbody         |  6910 |  4824 |  5446 |  3784 |
| nsieve        |  3556 |  2080 |  2788 |  1580 |
| nsievebits    |  3935 |  2344 |  3043 |  1760 |
| perlin        |  9748 |  6744 |  7444 |  5064 |
| qsort         |  4591 |  3352 |  3575 |  2476 |
| sha1          |  8293 |  6200 |  6417 |  4700 |
| sha3          |  8921 |  6592 |  8565 |  6764 |
| siphash24     |  8251 |  6080 |  6967 |  5440 |
| spectral      |  5325 |  3456 |  4145 |  2636 |
| vmach         |  6353 |  4872 |  4729 |  3464 |


### Comparison of development with CompCertELF

We show a comparison with CompCert in terms of the work of
implementaion and proof in Section 5.2 of the paper. Here we give
detailed explanation.

The effort for supporting verified instruction encoding for X86 is
summarized in the following table.

```text
+--------------------------------------------------------------+
|                                | CompCertELF  | Our Approach |
|    Statistics for X86          -------------------------------
|                                | Spec | Proof | Spec | Proof |
+--------------------------------------------------------------+
|  Supported Instructions        | 89   | 24    | 146  |  146  |
+--------------------------------------------------------------+
|  Instruction Encoding (Coq)    | 966  | 1356  | 2178 |  469  |
|  Instruction Encoding (CSLED)  | 0    | 0     | 150  |  0    |
+--------------------------------------------------------------+
```

CompCertELF supports a subset of x86-32. To compile the test cases
presented in the CompCertELF paper, an encoding algorithm for 89
X86-32 instructions is implemented. As a proof-of-concept, 24 out of
the 89 instructions are fully verified (manually proved in Coq that
their decoding is the inverse of encoding), which are sufficient to
support the paper's main example. 966 lines of Coq are written for
specifying 89 instructions (of which 374 lines are for the 24 verified
instructions) and 1356 lines of proofs (in Coq) are written to verify
the encoding of the 24 instructions.

By contrast, our framework supports all the X86-32 and X86-64
instructions used in CompCert (after pretty printing), i.e., a total
of 146 instructions (among which 112 are for both X86-32 and X86-64
and 34 are pure 64-bit instructions). As shown in Table 1 of the
paper, our effort is composed of two parts: 1) 150 lines of CSLED
specifications (in [x86.csled](csled/x86/x86.csled)) for automatically
generating encoders and decoders, and
2) 2178 lines of specification and 469 lines of proofs (in Coq) to
implement and verify the instruction translator (in
[x86/TranslateInstr.v](x86/TranslateInstr.v) and
[x86/RelocBinDecode.v](x86/RelocBinDecode.v)).


By the above statistics, one needs to write about 72 lines of code for
verifying one instruction in CompCertELF ( (374+1356)/24 ~= 72 ). On
the other hand, one only needs to write about 20 lines of code for
verifying one instruction using our framework ( (2178+469+150)/146 ~=
19 ). As the total number of instructions grows, the effort saved can
be quite significant.

Finally, CompCertELF does not support RISC-V. In comparison, we
support all 119 RISC-V instructions used in CompCert (after pretty
printing) with statistics in Table 1 of our paper (which we do not
repeat here).