fn example1(a: i32, b: Box<i32>) {
    a = *b;
    let c : Box<i32> in {
        if a < *b {
            c = b;
        }
        else {
            b = Box(3);
        }
    }
}

// factorial
fn example2() -> Box<i32> {
    let n : i32 in{
        n = 10;
        let a : i32 in {
            a = 1;
            let b : i32 in{
                while (0 < n) {
                    let c : Box<i32> in{
                        c = Box(*b);
                        *c = (*b) * n;
                        n = n - 1;
                        b = c;
                    }
                }
                return b;
            }
        }
    }
}

// factorial again
fn example3() -> Box<i32> {
    let n : i32 in{
        n = 10;
        let a : i32 in {
            a = 1;
            let b : i32 in{
                while (1) {
                    let c : Box<i32> in{
                        c = Box(*b);
                        if (0 < n) {
                            *c = (*b) * n;
                            n = n - 1;
                            b = c;
                            continue;
                        }
                        else {
                            break;
                        }
                    }
                }
                return b;
            }
        }
    }
}

// Example 4
// The following test case is a whole program which implements a list

// declare
struct list_node;
enum list;

struct list_node {
    first : i32;
    second : Box<list>
};

enum list {
    nil : unit; // unit type
    cons : list_node
};

// It pop an element and then push the parameter into the list
fn pop_and_push(l: Box<list>, v: i32) -> Box<list> {
    let head : list_node in {
        head.first = v;
        match *l with {
            case list::nil as tl => {
                head.second = Box(nil(tl)); 
            }
            case list::cons as tl => {
                // tl has type list_node
                head.second = tl.second;
            }
        }
        return Box(cons(head));
    }
}


fn main(){
    let l : list := list::nil(tt) in {
        let head : list_node := list_node{first: 42, second: Box(l)} in{
            l = list::cons(head);
            let l' : Box<list> := Box(l) in {
                l' = push_and_pop(l', -2);
                return 0;
            }
        } 
    }
}


// Example 5: a program with complicated structure definitions and
partial ownership transfer, which is used to test the initialized
analysis

struct S1 {
    l: Box<i32>,
    m: Box<i32>,
    n: i32
}

struct S2 {
    f: Box<Box<S1>>,
    g: Box<i32>,
    h: i32
}


fn main(){
    let a = S2 {
        f: Box::new(Box::new(
            S1 {l: Box::new(1), 
                m: Box::new(2), 
                n: 3}
            )),
        g: Box::new(4), 
        h: 5
    };
    let b = (**(a.f)).l;

    // inserted drops:
    
    // drop(b);

    // drop((**(a.f)).m);
    // drop(*(a.f));
    // drop(a.f);
    // drop(a.g);
}